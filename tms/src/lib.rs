//! `tms` module provides binary packing compression using SIMD instructions.
//!
//! `tms` supports 256-bit SIMD vectors with AVX2.
//!
//! `tms` is based on "SIMD Compression and the Intersection of Sorted Integers"
//! by Daniel Lemire, Leonid Boytsov, and Nathan Kurz.
//!
//! See the journal article https://arxiv.org/abs/1401.6399.
//!
//! See the C++ implementation https://github.com/lemire/SIMDCompressionAndIntersection.
//!
//! See a blog on implmenting the algorithm https://fulmicoton.com/posts/bitpacking/.
//!
//! See a Rust implementation https://docs.rs/crate/bitpacking/0.8.4.
//!
//! See Intel SIMD documentation https://software.intel.com/sites/landingpage/IntrinsicsGuide/.

// Create ASCII tables at https://ozh.github.io/ascii-tables/. 
#![cfg_attr(debug_assertions, allow(dead_code, unused_imports, unused_variables))]
#![feature(portable_simd)]
#![feature(is_sorted)]
extern crate rand;

// Import "data" for benches and testing.
pub mod dat;

// Import variable integer compression module.
pub mod vrn;

// Some used by functions generated by macros.
use std::arch::x86_64::__m256i as m256;
use std::arch::x86_64::_mm256_add_epi32 as add;
use std::arch::x86_64::_mm256_and_si256 as and;
use std::arch::x86_64::_mm256_lddqu_si256 as load;
use std::arch::x86_64::_mm256_or_si256 as or;
use std::arch::x86_64::_mm256_set1_epi32 as set1;
use std::arch::x86_64::_mm256_slli_epi32 as lft;
use std::arch::x86_64::_mm256_srli_epi32 as rht;
use std::arch::x86_64::_mm256_storeu_si256 as store;
use std::arch::x86_64::_mm256_sub_epi32 as sub;
use std::ptr;
use core_simd::*;
use chrono::naive::{NaiveDate, NaiveDateTime, NaiveTime};
use chrono::Datelike;
use chrono::Duration;
use u32;
use i32;

/// `BIT_PER_BYT` is the number of bits per byte.
const BIT_PER_BYT: usize = 8;
/// `BIT_PER_ELM` is the number of bits per 32-bit element.
const BIT_PER_ELM: usize = 32;
/// `BIT_PER_LNE` is the number of bits per SIMD lane.
/// 
/// This is the same as `BIT_PER_ELM`, and can be convient to think in terms of SIMD lanes.
const BIT_PER_LNE: usize = 32;
/// `BIT_PER_SMD` is the number of bits per SIMD vector.
const BIT_PER_SMD: usize = 256;
/// `BYT_PER_SMD` is the number of bytes per SIMD vector.
const BYT_PER_SMD: usize = 32;
/// `ELM_PER_SMD` is the number of 32-bit elements per SIMD vector.
const ELM_PER_SMD: usize = 8;
/// `MIN_ELM_PER_BLK` is the inclusive minimum number of 32-bit elements per block.
/// This is two SIMD vectors.
const MIN_ELM_PER_BLK: usize = 16;
/// `BLK_256` is a block with 256 elements. 
const BLK_256: usize = 256;

// Generate compression methods
use mcr::u32_blk;
u32_blk!(256);

/// `TmeMli` is a sequence of NaiveDateTimes for multiple days.
/// 
/// `TmeMli` is the main struct for clients of the `tms` module.
/// 
/// Uncompressed inputs are a list of 12-byte NaiveDateTimes.
/// 
/// Internally `TmeMli` stores compressed state in a list of bytes.
/// 
/// `TmeMli` is intentionally designed for stock market data. Limiting the scope to stock market data improves space compression.
/// 
/// Values are compressed and accessible by day.
/// 
/// A day is based on the NYSE Core Trading Session from 9:30am to 4:00pm ET.
/// Values before 9:30am ET and after 4:00pm ET are invalid, and dropped when added.
/// 
/// A day is limited to u32::MAX values per day, which is 4,294,967,295. This is sufficient for most purposes, and is made to improve the compression ratio.
/// 
/// `TmeMli` is designed for fast decompression and good space compression.
///  
/// See NYSE hours https://www.nyse.com/markets/hours-calendars.
///
// +------------------+-----------+--------------+---------------+
// |    First Day     | Day Count | Day Ref Idxs |  Day Values   |
// +------------------+-----------+--------------+---------------+
// | i32 days from CE | u32       | u32s         | Binary packed |
// +------------------+-----------+--------------+---------------+
pub struct TmeMli {
  pub buf: Vec<u8>,
}
/// `IDX_DAY_FST` is the buffer index to the `First Day` i32 in TmeMli.
const IDX_DAY_FST: usize = 0;
/// `IDX_DAY_CNT` is the buffer index to the `Day Count` u32 in TmeMli.
const IDX_DAY_CNT: usize = 4;
/// `IDX_DAY_REF` is the buffer index to the first u32 `Day Ref Idx` in TmeMli.
const IDX_DAY_REF: usize = 8;
/// `LEN_DAY_FST` is the number bytes used to store an i32 `First Day` in TmeMli.
const LEN_DAY_FST: usize = 4;
/// `LEN_DAY_CNT` is the number bytes used to store a u32 `Day Count` in TmeMli.
const LEN_DAY_CNT: usize = 4;
/// `LEN_DAY_REF` is the number bytes used to store a u32 `Day Ref Idx` in TmeMli.
const LEN_DAY_REF: usize = 4;

impl TmeMli {
  
  /// `new` returns a new instance of `TmeMli`.
  pub fn new() -> TmeMli {
    // Initialize with 8 bytes for `First Day` and `Day Count`
    return TmeMli {
      buf: vec![0; 8],
    }
  }

  /// `u32s` converts NaiveDateTimes to u32s.
  pub fn u32s(day: &[NaiveDateTime]) -> Vec<u32> {
    // TODO: SUBTRACT DATE
    let tme_min = NaiveTime::from_hms(9, 30, 0);
    let mut unp = vec![0u32; day.len()];
    for n in 0..day.len() {
      unp[n] = (day[n].time() - tme_min).num_milliseconds() as u32;
    }
    return unp;
  }

  /// `ndts` converts unpacked u32s to NaiveDateTimes with the specified date.
  pub fn ndts(day_unp: &mut [u32], day: NaiveDate) -> Vec<NaiveDateTime> {
    // TODO: ADD DATE
    let tme_min = NaiveTime::from_hms(9, 30, 0);
    let mut tmes: Vec<NaiveDateTime> = Vec::with_capacity(day_unp.len());
    unsafe {
      tmes.set_len(day_unp.len());
    }
    for n in 0..day_unp.len() {
      tmes[n] = NaiveDateTime::new(day, tme_min + Duration::milliseconds(day_unp[n] as i64));
    }
    return tmes;
  }

  /// `trim` trims values before 9:30am and after 4:00pm ET.
  pub fn trim(mut day: &[NaiveDateTime]) -> Option<&[NaiveDateTime]> {
    // Trim values less than trading day start 9:30am ET
    let tme_min = NaiveTime::from_hms(9, 30, 0);
    let day_min = NaiveDateTime::new(
      day[0].date(),
      tme_min,
    );
    let mut idx: usize = 0;
    while idx < day.len() && day[idx] < day_min {
      idx += 1;
    }
    day = &day[idx..];
    if day.len() == 0 {
      return None;
    }

    // Trim values greater than or equal to trading day end 4:00pm ET
    let day_max = NaiveDateTime::new(
      day[0].date(),
      NaiveTime::from_hms(16, 0, 0),
    );
    idx = day.len() - 1;
    while idx > 0 && day[idx] >= day_max {
      idx -= 1;
    }
    day = &day[..idx+1];
    if day[0] >= day_max {
      return None;
    }

    return Some(day);
  }

  /// `append_day` appends a day of NaiveDateTimes.
  /// 
  /// Values before 9:30am and after 4:00pm ET are dropped.
  /// 
  /// Specifying more than one day results in dropping days greater than the first day.
  pub fn append_day(&mut self, mut day: &[NaiveDateTime]) {
    println!("-- append_day");
    if day.len() == 0 {
      return;
    }

    // Trim values less than trading day start 9:30am ET
    // Trim values greater than or equal to trading day end 4:00pm ET
    let opt = TmeMli::trim(day);
    if opt == None {
      return;
    }
    day = opt.unwrap();

    // Day is non-zero, and trimmed within the min-max day limits
    unsafe {
      // Read `Day Count` from buf bytes
      let day_cnt_prv = u32::from_ne_bytes( *(self.buf[IDX_DAY_CNT..].as_ptr() as *const [u8; LEN_DAY_CNT]) );

      // Increment `Day Count`
      let day_cnt_new = day_cnt_prv + 1;

      // Write new `Day Count`
      ptr::copy_nonoverlapping(
        day_cnt_new.to_ne_bytes().as_ptr() as *const u8, 
        self.buf[IDX_DAY_CNT..].as_mut_ptr(), 
        LEN_DAY_CNT);

      // Write `First Day` i32 days from CE
      if day_cnt_prv == 0 {
        ptr::copy_nonoverlapping(
          day[0].num_days_from_ce().to_ne_bytes().as_ptr() as *const u8, 
          self.buf.as_mut_ptr(), 
          LEN_DAY_FST);
      }

      // Convert NaiveDateTimes to u32s
      let unp = TmeMli::u32s(day);

      // Calculate size of compressed day
      let day_len = DayLen::u32x256(&unp);

      // // Record the index of the packed day values
      // // Add LEN_DAY_REF to accomdate the length of an additional index value
      // let idx_day_val = (LEN_DAY_REF + self.buf.len()) as u32;

      // Calculate the length of previous binary packed values for shifting
      // Use the original self.buf.len() before expansion
      // let org_vals_len = self.buf.len() - IDX_DAY_REF - (day_cnt as usize * LEN_DAY_REF);

      // Record the previous buffer length
      let buf_len_prv = self.buf.len();
      println!("buf_len_prv {}", buf_len_prv);

      // Calculate previous header length = `First Day` + `Day Count` + `Day Ref Idxs`
      let hdr_len_prv = LEN_DAY_FST + LEN_DAY_CNT + (day_cnt_prv as usize * LEN_DAY_REF);
      println!("hdr_len_prv {}", hdr_len_prv);

      // Reserve new space in the buffer for the appended day
      // 4 bytes for a u32 index to the starting byte of the values
      // N bytes for the binary packed values themselves
      self.buf.resize(self.buf.len() + LEN_DAY_REF + day_len.byt_len, 0);
      // self.buf.reserve_exact(LEN_DAY_REF + day_len.byt_len);
      // self.buf.set_len(self.buf.len() + LEN_DAY_REF + day_len.byt_len);
      println!("new self.buf.len() {}", self.buf.len());
      println!("grow len {}", LEN_DAY_REF + day_len.byt_len);

      let expanded = &self.buf[self.buf.len()-32..];
      println!("expanded {:?}", &expanded);
      
      // Shift existing day binary packed forward to allow room for a new `Day Ref Idx`
      // Shift forward by 4 bytes allowing room for a single new u32 `Day Ref Idx`
      if day_cnt_prv != 0 {
        // Read `Day Ref Idx` of first previous values
        let idx_vals_prv = u32::from_ne_bytes( *(self.buf[IDX_DAY_REF..].as_ptr() as *const [u8; LEN_DAY_REF]) ) as usize;
        // Calculate the sized of all previous values
        let len_vals_prv = buf_len_prv - idx_vals_prv;
        println!("idx_vals_prv {}", idx_vals_prv);
        println!("len_vals_prv {}", len_vals_prv);

        let shf_prv = &self.buf.clone()[idx_vals_prv..];

        let buf_a = &self.buf.clone()[..32];
        println!("buf_a {:?}", &buf_a);
        
        // Shift all binary packed values forward 4 bytes
        ptr::copy(
          self.buf[idx_vals_prv..].as_ptr(),
          self.buf[(idx_vals_prv + LEN_DAY_REF)..].as_mut_ptr(),
          len_vals_prv,
        );

        let buf_b = &self.buf.clone()[..32];
        println!("buf_b {:?}", &buf_b);

        let shf_nxt = &self.buf[(idx_vals_prv + LEN_DAY_REF)..];
        println!("shf_prv.len() {}", shf_prv.len());
        println!("shf_nxt.len() {}", shf_nxt.len());
        let idx: usize = len_vals_prv - 16;
        let lim: usize = idx + 16;
        let shf_prv2 = &shf_prv[idx..lim];
        let shf_nxt2 = &shf_nxt[idx..lim];
        println!("shf_prv {:?}", shf_prv2);
        println!("shf_nxt {:?}", shf_nxt2);
        // assert_eq!(shf_prv, shf_nxt);

        // Increment all previous `Day Ref Idx` values by 4 to accomodate new u32 `Day Ref Idx`
        for n in 0..day_cnt_prv {
          let idx_ref_prv = IDX_DAY_REF + (n as usize * LEN_DAY_REF);
          println!("idx_ref_prv {}", idx_ref_prv);
          // Read existing `Day Ref Idx`
          let mut idx_val_prv = u32::from_ne_bytes( *(self.buf[idx_ref_prv..].as_ptr() as *const [u8; LEN_DAY_REF]) );
          println!("idx_val_prv {}", idx_val_prv);
          // Increment current `Day Ref Idx` value by 4 bytes
          idx_val_prv += LEN_DAY_REF as u32;
          println!("idx_val_upd {}", idx_val_prv);
          // Write existing and incremented `Day Ref Idx`
          ptr::copy_nonoverlapping(
            idx_val_prv.to_ne_bytes().as_ptr() as *const u8, 
            self.buf[idx_ref_prv..].as_mut_ptr(), 
            LEN_DAY_REF);
        }
      }

      // Calculate the index of the new `Day Ref Idx`
      let idx_ref_new = IDX_DAY_REF + (day_cnt_prv as usize * LEN_DAY_REF);
      println!("idx_ref_new {}", idx_ref_new);
      
      // Calculate the value of the new `Day Ref Idx`
      // Add the previous buffer length and the size of a new u32 `Day Ref Idx`
      let idx_val_new = buf_len_prv + LEN_DAY_REF;
      println!("idx_val_new {}", idx_val_new);
      // Write new `Day Ref Idx`
      ptr::copy_nonoverlapping(
        idx_val_new.to_ne_bytes().as_ptr() as *const u8, 
        self.buf[idx_ref_new..].as_mut_ptr(), 
        LEN_DAY_REF);

      

      println!("day_cnt_prv {}", day_cnt_prv);
      println!("day_cnt_new {}", day_cnt_new);
      println!("day_len {:?}", &day_len);

      // Compress and write the day values
      day_u32x256_pck(&day_len, &unp, &mut self.buf[idx_val_new..]);
    }
  }

  /// `get_day` returns a decompressed day NaiveDateTimes.
  pub fn get_day(&self, day: NaiveDate) -> Option<Vec<NaiveDateTime>> {
    println!("-- get_day");

    unsafe {
      // Read `Day Count`
      let day_cnt = u32::from_ne_bytes( *(self.buf[IDX_DAY_CNT..].as_ptr() as *const [u8; LEN_DAY_CNT]) ) as i32;
      println!("day_cnt {}", day_cnt);
      // Read `First Day` i32 days from CE
      let day_fst_from_ce = i32::from_ne_bytes( *(self.buf.as_ptr() as *const [u8; LEN_DAY_FST]) );
      // Calculate the index of the specified day being requested
      let day_cur_from_ce = day.num_days_from_ce();
      let day_idx = day_cur_from_ce - day_fst_from_ce;
      println!("day_idx {}", day_idx);

      // Check if the requested day is available
      if day_idx < 0 || day_idx >= day_cnt {
        return None;
      }
      
      // Calculate the index to `Day Ref Idx`
      let idx_ref = IDX_DAY_REF + (LEN_DAY_REF * (day_idx as usize));
      println!("idx_ref {}", idx_ref);

      // Read `Day Ref Idx`
      let idx_val = u32::from_ne_bytes( *(self.buf[idx_ref..].as_ptr() as *const [u8; LEN_DAY_REF]) ) as usize;
      println!("idx_val {}", idx_val);

      // Create a slice starting at the day's packed bytes
      let day_pck = &self.buf[idx_val..];
      // Create a vector of u32s for the unpacked values
      let mut day_unp = vec![0u32; day_u32x256_cnt(day_pck)];
      println!("day_unp.len() {}", day_unp.len());

      // Unpack the day to u32s
      day_u32x256_unp(&day_pck, &mut day_unp);

      // Convert u32s to NaiveDateTimes
      let tmes = TmeMli::ndts(&mut day_unp, day);

      return Some(tmes);
    }
  }
}

/// `DayLen` represents the number of bytes used to store a compressed day.
#[derive(Debug, Clone)]
pub struct DayLen {
  pub blk_bit_lens: Vec<u8>,
  pub blk_byt_lens: Vec<usize>,
  pub byt_len: usize,
}

impl DayLen {

  /// `u32x256` returns the number of bytes used to store a compressed day.
  /// 
  // +-------------------+-------------------+-------------------+-----------------------+---------------+----------------------+
  // |  Total U32 Count  |    Block Count    | Block Bit-Lengths | First U32 Block Value | Block Values  | Remaining U32 Values |
  // +-------------------+-------------------+-------------------+-----------------------+---------------+----------------------+
  // | Varint compressed | Varint compressed | Uncompressed u8s  | Varint compressed     | Binary packed | Varint compressed    |
  // +-------------------+-------------------+-------------------+-----------------------+---------------+----------------------+
  pub fn u32x256(unp: &[u32]) -> DayLen {
    let mut r = DayLen{
      blk_bit_lens: Vec::new(),
      blk_byt_lens: Vec::new(),
      byt_len: 0,
    };
    // Add `Total U32 Count` byte length
    r.byt_len += vrn::usize_byt_len(unp.len());
    if unp.len() != 0 {
      // Calculate block count
      let blk_cnt = unp.len() / BLK_256;
      // Add `Block Count` byte length
      r.byt_len += vrn::usize_byt_len(blk_cnt);
      if blk_cnt != 0 {
        // Add `Block Bit-Lengths` byte length
        r.byt_len += blk_cnt;
        // Add `First U32 Block Value` byte length
        r.byt_len += vrn::u32_byt_len(unp[0]);
        // Calculate block bit-lengths and byte sizes
        unsafe {
          for n in 0..blk_cnt {
            let blk_cur = &unp[n*BLK_256..(n+1)*BLK_256];
            // Store bit-lengths for later encoding
            r.blk_bit_lens.push(u32x256_bit_len(&blk_cur));
            // Store byte-lengths for later encoding
            r.blk_byt_lens.push(u32x256_byt_len(r.blk_bit_lens[n]));
            // Add `Block Values` byte length
            r.byt_len += r.blk_byt_lens[n];
          }
        }
      }
      // Calculate remaining elements byte length
      if unp.len() % BLK_256 != 0 {
        // Add `Remaining U32 Values` byte length
        r.byt_len += vrn::u32s_byt_len(&unp[blk_cnt*BLK_256..]);
      }
    }

    return r;
  }
}

/// `day_u32x256_pck` compresses a day of u32s into packed bytes.
/// 
// Compression is laid out as:
// 
// +-------------------+-------------------+-----------------------+------------------+---------------+----------------------+
// |  Total U32 Count  |    Block Count    | First U32 Block Value | Block Bit-Length |  Block Value  | Remaining U32 Values |
// +-------------------+-------------------+-----------------------+------------------+---------------+----------------------+
// | Varint compressed | Varint compressed | Varint compressed     | Uncompressed u8  | Binary packed | Varint compressed    |
// +-------------------+-------------------+-----------------------+------------------+---------------+----------------------+
// 
//   Total U32 Count   - The total number of u32 elements in the day.
//   Block Count       - The number of blocks and block bit-lengths.
//   First U32 Block Value - The first u32 value of the first block.
//   Block Bit-Length  - Uncompressed u8 representing the current block's bit-length.
//   Block Value       - An array of bytes for binary-packed u32 values segemented into blocks of 256.
//   Remaining Values  - An array of bytes for variable integer encoded u32 values. There are less than 256 u32 values.
pub fn day_u32x256_pck(day: &DayLen, mut unp: &[u32], mut pck: &mut [u8]) {
  // Write `Total U32 Count` and advance packed slice
  let mut len = vrn::usize_pck(unp.len(), pck);
  pck = &mut pck[len..];

  if unp.len() != 0 {
    // Write `Block Count` and advance packed slice
    len = vrn::usize_pck(day.blk_bit_lens.len(), pck);
    pck = &mut pck[len..];

    if day.blk_bit_lens.len() != 0 {
      // Write `First U32 Block Value` and advance packed slice
      let mut fst = unp[0];
      len = vrn::u32_pck(fst, pck);
      pck = &mut pck[len..];

      // Binary pack blocks
      for n in 0..day.blk_bit_lens.len() {
        // Write current `Block Bit-Length` and advance packed slice
        pck[0] = day.blk_bit_lens[n];
        pck = &mut pck[1..];

        unsafe {
          // Write `Block Value`
          u32x256_pck(day.blk_bit_lens[n], fst, unp, pck);
        }
        // Assign last element of current block as first element of next block
        fst = unp[BLK_256-1];
        // Advance unpacked slice
        unp = &unp[BLK_256..];
        // Advance packed slice
        pck = &mut pck[day.blk_byt_lens[n]..];
      }
    }

    // Compress remaining elements with varint encoding
    if unp.len() % BLK_256 != 0 {
      vrn::u32s_pck(unp, pck);
    }
  }
}

/// `day_u32x256_cnt` returns the total number of u32 elements in the packed day.
pub fn day_u32x256_cnt(pck: &[u8]) -> usize {
  // Read `Total U32 Count` with varint decoding
  return vrn::usize_unp(pck).val;
}

/// `day_u32x256_unp` decompresses packed bytes into a day of u32s.
/// 
// Compression is laid out as:
// 
// +-------------------+-------------------+-----------------------+------------------+---------------+----------------------+
// |  Total U32 Count  |    Block Count    | First U32 Block Value | Block Bit-Length |  Block Value  | Remaining U32 Values |
// +-------------------+-------------------+-----------------------+------------------+---------------+----------------------+
// | Varint compressed | Varint compressed | Varint compressed     | Uncompressed u8  | Binary packed | Varint compressed    |
// +-------------------+-------------------+-----------------------+------------------+---------------+----------------------+
pub fn day_u32x256_unp(mut pck: &[u8], mut unp: &mut [u32]) {
  // Read `Total U32 Count` with varint decoding and advance packed slice
  let tot_u32 = vrn::usize_unp(pck);
  pck = &pck[tot_u32.len..];
  if tot_u32.val == 0 {
    return;
  }
  
  // Read `Block Count`
  let tot_blk = vrn::usize_unp(pck);
  pck = &pck[tot_blk.len..];

  if tot_blk.val != 0 {
    // Read `First U32 Block Value` and advance packed slice
    let fst_unp = vrn::u32_unp(pck);
    pck = &pck[fst_unp.len..];

    // Binary unpack blocks
    let mut fst = fst_unp.val;
    for n in 0..tot_blk.val {
      // Read `Block Bit-Length` and advance packed slice
      let blk_bit_len = pck[0];
      pck = &pck[1..];

      unsafe {
        // Read `Block Value`
        u32x256_unp(blk_bit_len, fst, pck, unp);
      }
      // Assign last element of current block as first element of next block
      fst = unp[BLK_256-1];
      // Advance unpacked slice
      unp = &mut unp[BLK_256..];
      // Advance packed slice
      pck = &pck[u32x256_byt_len(blk_bit_len)..];
    }
  }

  // Decompress remaining elements with varint decoding
  if tot_u32.val % BLK_256 != 0 {
    vrn::u32s_unp(pck, unp);
  }
}

pub fn day_u32x256_vld(day: &DayLen, mut unp_exp: &[u32]) {
  let mut pck_v = vec![0u8; day.byt_len];
  let mut pck = pck_v.as_mut_slice();
  let mut unp_act_v = vec![0u32; unp_exp.len()];
  let mut unp_act = unp_act_v.as_mut_slice();

   // day_u32x256_pck: Write `Total U32 Count` and advance packed slice
   let mut len = vrn::usize_pck(unp_exp.len(), pck);
   // day_u32x256_unp: Read `Total U32 Count` with varint decoding and advance packed slice
   let tot_u32 = vrn::usize_unp(pck);
   println!("Total U32 Count        pck,len {},{} unp {:?}", unp_exp.len(), len, tot_u32);
   pck = &mut pck[len..];

   // day_u32x256_pck: Write `Block Count` and advance packed slice
   len = vrn::usize_pck(day.blk_bit_lens.len(), pck);
   // day_u32x256_unp: Read `Block Count`
  let tot_blk = vrn::usize_unp(pck);
  println!("Block Count            pck,len {},{} unp {:?}", day.blk_bit_lens.len(), len, tot_blk);
  pck = &mut pck[len..];

  // day_u32x256_pck: Write `First U32 Block Value` and advance packed slice
  let mut fst_pck = unp_exp[0];
  len = vrn::u32_pck(fst_pck, pck);
  // day_u32x256_unp: Read `First U32 Block Value` and advance packed slice
  let fst_unp0 = vrn::u32_unp(pck);
  println!("First U32 Block Value  pck,len {},{} unp {:?}", unp_exp[0], len, fst_unp0);
  pck = &mut pck[len..];


  let mut fst_unp = fst_unp0.val;

  // Binary pack/unpack blocks
  for n in 0..day.blk_bit_lens.len() {
    println!("----------------       n {}", n);

    // day_u32x256_pck: Write current `Block Bit-Length` and advance packed slice
    pck[0] = day.blk_bit_lens[n];
    // day_u32x256_unp: Read `Block Bit-Length` and advance packed slice
    let blk_bit_len = pck[0];
    println!("Block Bit-Length       n {}  pck {} unp {}", n, pck[0], blk_bit_len);
    pck = &mut pck[1..];

    unsafe {
      // day_u32x256_pck: Write `Block Value`
      u32x256_pck(day.blk_bit_lens[n], fst_pck, unp_exp, pck);
      // day_u32x256_unp: Read `Block Value`
      u32x256_unp(blk_bit_len, fst_unp, pck, unp_act);
    }
    println!("First Value            n {}  pck {}  unp {}", n, fst_pck, fst_unp);
    println!("Block Value            n {}  pck == unp {}", n, unp_exp[..BLK_256] == unp_act[..BLK_256]);
    for n in 0..BLK_256 {
      if unp_exp[n] != unp_act[n] {
        println!("{}  neq  exp {}  act {}", n, unp_exp[n], unp_act[n]);
        break;
      }
    }

    // day_u32x256_pck: Assign last element of current block as first element of next block
    fst_pck = unp_exp[BLK_256-1];
    // day_u32x256_pck: Advance unpacked slice
    unp_exp = &unp_exp[BLK_256..];

    // day_u32x256_unp: Assign last element of current block as first element of next block
    fst_unp = unp_act[BLK_256-1];
    // day_u32x256_unp: Advance unpacked slice
    unp_act = &mut unp_act[BLK_256..];


    let bit_len_pck = day.blk_byt_lens[n];
    let bit_len_unp = u32x256_byt_len(blk_bit_len);
    println!("Computed Bit-Length    n {}  pck {}  unp {}", n, bit_len_pck, bit_len_unp);

    // Advance packed slice
    pck = &mut pck[day.blk_byt_lens[n]..];

    // TODO: REMOVE
    break;
  }
}

#[cfg(test)]
mod tst {
  use super::*;
  // use anyhow::Result;
  use chrono::{DateTime, TimeZone, Utc, Duration};
  use chrono::naive::*;
  use chrono::prelude::*;
  use dat::*;
  use dat::goog;
  use std::fmt::Debug;
  use std::fs::{self, DirEntry, File};
  use std::io::{Result};
  use std::mem;
  use std::path::{PathBuf};
  use std::path::Path;
  use vrn;

  /// `DAT_BSE_DIR` is the base CSV data directory.
  const DAT_BSE_DIR: &str = "/home/rana/prj/dat/duk/GOOG/csv/";
  // `TME_PRS_FMT` is the CSV DateTime parsing format.
  const TME_PRS_FMT: &str = "%d.%m.%Y %X%.3f";

  pub fn load_csv_tmes(fle: &str) -> Vec<NaiveDateTime> {
    let pth = format!("{}{}", DAT_BSE_DIR, fle);
    let rdr = csv::Reader::from_path(pth).unwrap();
    return rdr_tmes(rdr);
  }
  pub fn rdr_tmes(mut rdr: csv::Reader<File>) -> Vec<NaiveDateTime> {
    // CSV data layout
    // Local time,Ask,Bid,AskVolume,BidVolume
    // 04.05.2020 06:30:00.143 GMT-0700,1309.632,1307.818,0.0008,0.0008
    // 04.05.2020 06:30:00.193 GMT-0700,1309.632,1307.838,0.002,0.002
    // Day.Month.Year  Times are from PDT Pacific time
    // Shift 3 hours to move to Eastern time
    let mut tmes = Vec::new();
    for res in rdr.records() {
      let record = res.expect("a CSV record");
      tmes.push(
        NaiveDateTime::parse_from_str(&record[0][..23], TME_PRS_FMT).unwrap() + Duration::hours(3),
      );
    }
    return tmes;
  }


  pub fn pths() -> Vec<PathBuf> {
    let mut pths: Vec<PathBuf> = fs::read_dir(DAT_BSE_DIR).unwrap()
      .map(|x| x.unwrap().path())
      .collect::<Vec<PathBuf>>();
    pths.sort();
    return pths;
  }

  #[test]
  fn tme_empty() {
    let tme = TmeMli::new();
    assert_eq!(tme.get_day(NaiveDate::from_ymd(2010, 3, 14)), None);
  }

  #[test]
  fn tme_day_1_simple_a() {
    let day_exp = load_csv_tmes("2020-05-04.csv");
    let mut tme = TmeMli::new();
    tme.append_day(&day_exp);
    let day_act = tme.get_day(day_exp[0].date()).unwrap();
    assert_eq!(day_exp, day_act);
  }

  #[test]
  fn tme_day_1_simple_b() {
    println!("-- tme_day_1_simple_b");
    let day_exp = load_csv_tmes("2020-05-05.csv");
    let mut tme = TmeMli::new();
    tme.append_day(&day_exp);
    let day_act = tme.get_day(day_exp[0].date()).unwrap();
    
    // println!("day_exp.len {}", day_exp.len());
    // println!("day_act.len {}", day_act.len());
    // println!("day_exp[0] {}", day_exp[0]);
    // println!("day_exp[1] {}", day_exp[1]);
    // println!("day_exp[2] {}", day_exp[2]);
    // println!("day_act[0] {}", day_act[0]);
    // println!("day_act[1] {}", day_act[1]);
    // println!("day_act[2] {}", day_act[2]);
    for n in 0..day_exp.len() {
      if day_exp[n] != day_act[n] {
        println!("{}  neq  exp {}  act {}", n, day_exp[n], day_act[n]);
        break;
      }
    }
    // assert_eq!(day_exp, day_act);
  }

  #[test]
  fn tme_day_1_trim_min_max() {
    let day_exp = load_csv_tmes("2020-05-04.csv");
    let mut day = day_exp.clone();
    // Add val below min
    day.insert(0, day[0] + Duration::hours(-1));
    // Add val above max
    day.push(day[day.len() - 1] + Duration::hours(1));
    let mut tme = TmeMli::new();
    tme.append_day(&day);
    let day_act = tme.get_day(day_exp[0].date()).unwrap();
    assert_eq!(day_exp, day_act);
  }

  #[test]
  fn tme_day_1_trim_extra_day() {
    let day_exp = load_csv_tmes("2020-05-04.csv");
    let mut day = day_exp.clone();
    // Add second day
    let day2 = load_csv_tmes("2020-05-05.csv");
    day.extend_from_slice(&day2);
    let mut tme = TmeMli::new();
    tme.append_day(&day);
    let day_act = tme.get_day(day_exp[0].date()).unwrap();
    assert_eq!(day_exp, day_act);
  }

  #[test]
  fn tme_day_2() {
    let mut tme = TmeMli::new();
    // Append day 1
    let day1_exp = load_csv_tmes("2020-05-04.csv");
    tme.append_day(&day1_exp);
    // Append day 2
    let day2_exp = load_csv_tmes("2020-05-05.csv");
    tme.append_day(&day2_exp);
    
    let day1_act = tme.get_day(day1_exp[0].date()).unwrap();
    assert_eq!(day1_exp, day1_act);
    let day2_act = tme.get_day(day2_exp[0].date()).unwrap();
    assert_eq!(day2_exp, day2_act);
  }

  #[test]
  fn tme_day_3() {
    // TODO:
    // three append calls
  }

  #[test]
  fn tme_full() {
    // TODO:
    // all days appended
  }

  #[test]
  fn day_u32x256_pck_unp_empty() {
    let unp_exp = vec![];
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(0, day.blk_bit_lens.len());
    assert_eq!(1, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_blk0_1x0() {
    let unp_exp = vec![0u32];
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(0, day.blk_bit_lens.len());
    assert_eq!(3, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_blk0_1x1() {
    let unp_exp = vec![1u32];
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(0, day.blk_bit_lens.len());
    assert_eq!(3, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_blk0_1x128() {
    let unp_exp = vec![128u32];
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(0, day.blk_bit_lens.len());
    assert_eq!(4, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_blk0_2() {
    let unp_exp = vec![0, 1];
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(0, day.blk_bit_lens.len());
    assert_eq!(4, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_blk0_255() {
    let unp_exp = goog::blk255();
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(0, day.blk_bit_lens.len());
    assert_eq!(716, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_blk1_256() {
    let unp_exp = goog::blk256();
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(1, day.blk_bit_lens.len());
    assert_eq!(454, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_blk1_257() {
    let unp_exp = goog::blk257();
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(1, day.blk_bit_lens.len());
    assert_eq!(457, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_blk1_511() {
    let unp_exp = goog::blk511();
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(1, day.blk_bit_lens.len());
    assert_eq!(1219, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_blk2_512() {
    let unp_exp = goog::blk512();
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(2, day.blk_bit_lens.len());
    assert_eq!(903, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_blk2_513() {
    let unp_exp = goog::blk513();
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(2, day.blk_bit_lens.len());
    assert_eq!(906, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_full_inlnie() {
    let unp_exp = goog::day();
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    assert_eq!(92, day.blk_bit_lens.len());
    assert_eq!(44678, day.byt_len);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_full_a() {
    let day_tmes = load_csv_tmes("2020-05-04.csv");
    let unp_exp = TmeMli::u32s(&day_tmes);
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    let mut pck = vec![0u8; day.byt_len];
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    // println!("unp_exp {} unp_act {}", unp_exp.len(), unp_act.len());
    // for n in 0..unp_exp.len() {
    //   if unp_exp[n] != unp_act[n] {
    //     println!("{}  neq  exp {}  act {}", n, unp_exp[n], unp_act[n]);
    //     break;
    //   }
    // }
    assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_full_b()  {
    let day_tmes0 = load_csv_tmes("2020-01-14.csv");

    let mut day_tmes = TmeMli::trim(&day_tmes0).unwrap();
    // day_tmes = &day_tmes[..(day_tmes.len()/256)*256];
    day_tmes = &day_tmes[256*7..];
    let unp_exp = TmeMli::u32s(day_tmes);
    let mut unp_act = vec![0u32; unp_exp.len()];
    let day = DayLen::u32x256(&unp_exp);
    let mut pck = vec![0u8; day.byt_len];

    day_u32x256_vld(&day, &unp_exp);

    // Fails at idx 1792 of 2020-01-14.csv
    // 1792  neq  exp 831235  act 814851
    // 1792 / 256 = 7
    // ---
    // Changing start index to 1792
    // Fails at idx 19414
    // unp_exp 19414 unp_act 19414
    
    day_u32x256_pck(&day, &unp_exp, &mut pck);
    day_u32x256_unp(&pck, &mut unp_act);
    println!("unp_exp {} unp_act {}", unp_exp.len(), unp_act.len());
    for n in 0..unp_exp.len() {
      if unp_exp[n] != unp_act[n] {
        println!("{}  neq  exp {}  act {}", n, unp_exp[n], unp_act[n]);
        break;
      }
    }
    // assert_eq!(unp_exp, unp_act);
  }

  #[test]
  fn day_u32x256_pck_unp_all_goog_days() -> Result<()> {
    for pth in pths() {
      println!("{:?}", pth);
      let day_tmes = rdr_tmes(csv::Reader::from_path(pth).unwrap());
      let unp_exp = TmeMli::u32s(&day_tmes);
      let mut unp_act = vec![0u32; unp_exp.len()];
      let day = DayLen::u32x256(&unp_exp);
      let mut pck = vec![0u8; day.byt_len];
      day_u32x256_pck(&day, &unp_exp, &mut pck);
      day_u32x256_unp(&pck, &mut unp_act);
      assert_eq!(unp_exp, unp_act);
    }
    
    Ok(())
  }

  #[test]
  fn u32x256_rnd_0to32_bit_byt_pck_unp() {
    unsafe {
      for bit_len_exp in 0..=32u8 { 

        let unp_exp = gen_blk(256, bit_len_exp);
        let bit_len_act = u32x256_bit_len(unp_exp.as_slice());
        assert_eq!(bit_len_exp, bit_len_act);
        let byt_len = u32x256_byt_len(bit_len_act);
               
        let mut pck = vec![0u8; byt_len];
        let mut unp_act = vec![0u32; unp_exp.len()];
        let fst = unp_exp[0];

        u32x256_pck(bit_len_act, fst, unp_exp.as_slice(), &mut pck);
        u32x256_unp(bit_len_act, fst, &pck, unp_act.as_mut_slice());

        assert_eq!(unp_exp, unp_act);
      }
    }
  }

  #[test]
  fn u32x256_rnd_0_bit_byt_pck_unp() {
    unsafe {
      let bit_len_exp = 0u8;
      let unp_exp = gen_blk(256, bit_len_exp);
      let bit_len_act = u32x256_bit_len(unp_exp.as_slice());
      assert_eq!(bit_len_exp, bit_len_act);
      let byt_len = u32x256_byt_len(bit_len_act);

      let mut pck = vec![0u8; byt_len];
      let mut unp_act = vec![0u32; unp_exp.len()];
      let fst = unp_exp[0];

      u32x256_pck(bit_len_act, fst, unp_exp.as_slice(), &mut pck);
      u32x256_unp(bit_len_act, fst, &pck, unp_act.as_mut_slice());

      assert_eq!(unp_exp, unp_act);
    }
  }

  #[test]
  fn u32x256_rnd_32_bit_byt_pck_unp() {
    unsafe {
      let bit_len_exp = 32u8;
      let unp_exp = gen_blk(256, bit_len_exp);
      let bit_len_act = u32x256_bit_len(unp_exp.as_slice());
      assert_eq!(bit_len_exp, bit_len_act);
      let byt_len = u32x256_byt_len(bit_len_act);
      
      let mut pck = vec![0u8; byt_len];
      let mut unp_act = vec![0u32; unp_exp.len()];
      let fst = unp_exp[0];

      u32x256_pck(bit_len_act, fst, unp_exp.as_slice(), &mut pck);
      u32x256_unp(bit_len_act, fst, &pck, unp_act.as_mut_slice());

      assert_eq!(unp_exp, unp_act);
    }
  }

  #[test]
  fn u32x256_rnd_1_bit_byt_pck_unp() {
    unsafe {
      let bit_len_exp = 1u8;
      let unp_exp = gen_blk(256, bit_len_exp);
      let bit_len_act = u32x256_bit_len(unp_exp.as_slice());
      assert_eq!(bit_len_exp, bit_len_act);
      let byt_len = u32x256_byt_len(bit_len_act);

      let mut pck = vec![0u8; byt_len];
      let mut unp_act = vec![0u32; unp_exp.len()];
      let fst = unp_exp[0];

      u32x256_pck(bit_len_act, fst, unp_exp.as_slice(), &mut pck);
      u32x256_unp(bit_len_act, fst, &pck, unp_act.as_mut_slice());

      assert_eq!(unp_exp, unp_act);
    }
  }

  #[test]
  fn u32x256_rnd_14_bit_byt_pck_unp() {
    unsafe {
      let bit_len_exp = 14u8;
      let unp_exp = gen_blk(256, bit_len_exp);
      let bit_len_act = u32x256_bit_len(unp_exp.as_slice());
      assert_eq!(bit_len_exp, bit_len_act);
      let byt_len = u32x256_byt_len(bit_len_act);

      let mut pck = vec![0u8; byt_len];
      let mut unp_act = vec![0u32; unp_exp.len()];
      let fst = unp_exp[0];

      u32x256_pck(bit_len_act, fst, unp_exp.as_slice(), &mut pck);
      u32x256_unp(bit_len_act, fst, &pck, unp_act.as_mut_slice());
      
      assert_eq!(unp_exp, unp_act);
    }
  }

  #[test]
  fn u32x256_goog_14_bit_byt_pck_unp() {
    unsafe {
      let bit_len_exp = 14u8;
      let unp_exp = goog::blk256();
      let bit_len_act = u32x256_bit_len(unp_exp.as_slice());
      assert_eq!(bit_len_act, 14);
      let byt_len = u32x256_byt_len(bit_len_act);
      assert_eq!(byt_len, 448);

      let mut pck = vec![0u8; byt_len];
      let mut unp_act = vec![0u32; unp_exp.len()];
      let fst = unp_exp[0];

      u32x256_pck(bit_len_act, fst, unp_exp.as_slice(), &mut pck);
      u32x256_unp(bit_len_act, fst, &pck, unp_act.as_mut_slice());

      assert_eq!(unp_exp, unp_act);
    }
  }

  #[test]
  fn test_gen_blk_256() {
    unsafe {
      for bit_len_exp in 0..=32u8 {
        let blk = gen_blk(256, bit_len_exp);
        let bit_len_act = u32x256_bit_len(blk.as_slice());
        assert_eq!(bit_len_exp, bit_len_act);
        assert!(blk.is_sorted());
      }
    }
  }

}
